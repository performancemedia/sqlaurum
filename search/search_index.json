{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SQLAurum documentation Wrapper around SQLAlchemy async session, core and native features for Postgres/SQLite Version: 0.1.0 Docs: https://performancemedia.github.io/sqlaurum/ Repository: https://github.com/performancemedia/sqlaurum About This library provides glue code to use sqlalchemy async sessions, core queries and orm models from one object which provides somewhat of repository pattern. This solution has few advantages: no need to pass session object to every function/method. It is stored (and optionally injected) in repository object write data access queries in one place no need to import insert , update , delete , select from sqlalchemy over and over again Implicit cast of results to .scalars().all() or .one() Your view model (e.g. FastAPI routes) does not need to know about the underlying storage. Repository class can be replaced at any moment any object providint similar interface.","title":"SQLAurum"},{"location":"#welcome-to-sqlaurum-documentation","text":"Wrapper around SQLAlchemy async session, core and native features for Postgres/SQLite Version: 0.1.0 Docs: https://performancemedia.github.io/sqlaurum/ Repository: https://github.com/performancemedia/sqlaurum","title":"Welcome to SQLAurum documentation"},{"location":"#about","text":"This library provides glue code to use sqlalchemy async sessions, core queries and orm models from one object which provides somewhat of repository pattern. This solution has few advantages: no need to pass session object to every function/method. It is stored (and optionally injected) in repository object write data access queries in one place no need to import insert , update , delete , select from sqlalchemy over and over again Implicit cast of results to .scalars().all() or .one() Your view model (e.g. FastAPI routes) does not need to know about the underlying storage. Repository class can be replaced at any moment any object providint similar interface.","title":"About"},{"location":"installation/","text":"Installing package pip install sqlaurum or poetry install sqlaurum Installing optional dependencies: pip install 'sqlaurum[extension]' Available extensions: asyncpg aiosqlite alembic Installing multiple extensions: pip install 'sqlaurum[asyncpg, alembic]' Installing all pip install 'sqlaurum[all]'","title":"Installation"},{"location":"installation/#installing-package","text":"pip install sqlaurum or poetry install sqlaurum","title":"Installing package"},{"location":"installation/#installing-optional-dependencies","text":"pip install 'sqlaurum[extension]'","title":"Installing optional dependencies:"},{"location":"installation/#available-extensions","text":"asyncpg aiosqlite alembic","title":"Available extensions:"},{"location":"installation/#installing-multiple-extensions","text":"pip install 'sqlaurum[asyncpg, alembic]'","title":"Installing multiple extensions:"},{"location":"installation/#installing-all","text":"pip install 'sqlaurum[all]'","title":"Installing all"},{"location":"migrations/","text":"Alembic setup Example script how to configure alembic without installing psycopg2 or any other synchronous driver. import asyncio import os from logging.config import fileConfig from alembic import context # TODO: replace 2 lines below from myapp.db import engine from myapp.models import Base # optionally use your settings object url = os . getenv ( \"SQLALCHEMY_DATABASE_URL\" ) config = context . config if config . config_file_name is not None : fileConfig ( config . config_file_name ) target_metadata = Base . metadata def run_migrations_offline () -> None : context . configure ( url = url , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, ) with context . begin_transaction (): context . run_migrations () async def run_migrations_online (): def do_migrations ( connection ): context . configure ( connection = connection , target_metadata = target_metadata , dialect_opts = { \"paramstyle\" : \"named\" }, ) with context . begin_transaction (): context . run_migrations () async with engine . connect () as connection : await connection . run_sync ( do_migrations ) if context . is_offline_mode (): run_migrations_offline () else : asyncio . run ( run_migrations_online ())","title":"Alembic Migrations"},{"location":"migrations/#alembic-setup","text":"Example script how to configure alembic without installing psycopg2 or any other synchronous driver. import asyncio import os from logging.config import fileConfig from alembic import context # TODO: replace 2 lines below from myapp.db import engine from myapp.models import Base # optionally use your settings object url = os . getenv ( \"SQLALCHEMY_DATABASE_URL\" ) config = context . config if config . config_file_name is not None : fileConfig ( config . config_file_name ) target_metadata = Base . metadata def run_migrations_offline () -> None : context . configure ( url = url , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, ) with context . begin_transaction (): context . run_migrations () async def run_migrations_online (): def do_migrations ( connection ): context . configure ( connection = connection , target_metadata = target_metadata , dialect_opts = { \"paramstyle\" : \"named\" }, ) with context . begin_transaction (): context . run_migrations () async with engine . connect () as connection : await connection . run_sync ( do_migrations ) if context . is_offline_mode (): run_migrations_offline () else : asyncio . run ( run_migrations_online ())","title":"Alembic setup"},{"location":"repository/","text":"Repository pattern Implementing with sqlaurum Define your repository interface, preferably using Protocol from typing import Protocol , TypeVar , Optional EntityT = TypeVar ( \"EntityT\" ) class IRepository ( Protocol [ EntityT ]): async def add ( self , entity : EntityT ) -> None : ... async def get_by_id ( self , id ) -> Optional [ EntityT ]: ... UserT = TypeVar ( \"UserT\" ) # bound=DomainModel class IUserRepository ( IRepository [ UserT ]): async def get_user_by_name ( self , name : str ) -> UserT : ... Create sql repository from sqlaurum import create_repository_class from app.database.models import UserModel SqlRepository = create_repository_class ( ... ) class SqlUserRepository ( SqlRepository [ UserModel ]): async def get_by_id ( self , id ): return await self . one_or_none ( id = id ) async def get_user_by_name ( self , name : str ): return await self . one_or_none ( name = name ) That's it! Your application can now expect the IUserRepository which can be used for type annotations. Then you can pass/inject SqlUserRepository instance which conforms the interface protocol thanks to python duck typing system.","title":"Repository Pattern"},{"location":"repository/#repository-pattern","text":"","title":"Repository pattern"},{"location":"repository/#implementing-with-sqlaurum","text":"","title":"Implementing with sqlaurum"},{"location":"repository/#define-your-repository-interface-preferably-using-protocol","text":"from typing import Protocol , TypeVar , Optional EntityT = TypeVar ( \"EntityT\" ) class IRepository ( Protocol [ EntityT ]): async def add ( self , entity : EntityT ) -> None : ... async def get_by_id ( self , id ) -> Optional [ EntityT ]: ... UserT = TypeVar ( \"UserT\" ) # bound=DomainModel class IUserRepository ( IRepository [ UserT ]): async def get_user_by_name ( self , name : str ) -> UserT : ...","title":"Define your repository interface, preferably using Protocol"},{"location":"repository/#create-sql-repository","text":"from sqlaurum import create_repository_class from app.database.models import UserModel SqlRepository = create_repository_class ( ... ) class SqlUserRepository ( SqlRepository [ UserModel ]): async def get_by_id ( self , id ): return await self . one_or_none ( id = id ) async def get_user_by_name ( self , name : str ): return await self . one_or_none ( name = name )","title":"Create sql repository"},{"location":"repository/#thats-it","text":"Your application can now expect the IUserRepository which can be used for type annotations. Then you can pass/inject SqlUserRepository instance which conforms the interface protocol thanks to python duck typing system.","title":"That's it!"},{"location":"usage/","text":"Usage import sqlalchemy as sa from sqlalchemy.orm import declarative_base from sqlaurum import UUID , GenerateUUID , create_repository_class Base = declarative_base () class User ( Base ): __tablename__ = \"user\" id = sa . Column ( UUID (), primary_key = True , server_default = GenerateUUID (), nullable = False ) name = sa . Column ( sa . Unicode ( 255 )) SQLAlchemyRepository = create_repository_class ( \"postgresql\" ) class UserRepository ( SQLAlchemyRepository [ User ]): async def get_user_by_name ( self , name : str ): # custom user function return await self . select () . filter_by ( name = name ) . one () user_repository = UserRepository ( ... ) # select await user_repository . all () await user_repository . select () . where ( User . name == \"test\" ) # insert user = await user_repository . insert ({ \"name\" : \"test\" }) . one () await user_repository . commit () # upsert await user_repository . upsert ({ \"name\" : \"John\" }) # delete await user_repository . delete ( name = \"John\" ) # custom sqlalchemy core functions users = await user_repository . select () . join ( ... ) . filter ( User . name == \"test\" ) . filter_by ( ... ) . order_by ( User . created_at ) . limit ( 2 ) . all () Sessions Repository object needs sqlalchemy.ext.asyncio.AsyncSession , but it's possible to provide the session object by yourself, by subclassing Repository class e.g. from fastapi import Depends from sqlalchemy.ext.asyncio import create_async_engine , AsyncSession from sqlaurum import create_repository_class , create_session_factory engine = create_async_engine ( \"sqlite+aiosqlite:///:memory:\" ) get_db = create_session_factory ( engine ) BaseSQLAlchemyRepository = create_repository_class ( engine ) class SQLAlchemyRepository ( BaseSQLAlchemyRepository , abstract = True ): \"\"\"Base manager, which uses fastapi depends to get session object\"\"\" def __init__ ( self , session : AsyncSession = Depends ( get_db )): super () . __init__ ( session ) class UserRepository ( SQLAlchemyRepository [ User ]): ... # then in fastapi from fastapi import FastAPI app = FastAPI () @app . get ( \"/users\" ) async def get_users ( user_repo : UserRepository = Depends ( UserRepository )): users = await user_repo . all () return users","title":"Usage"},{"location":"usage/#usage","text":"import sqlalchemy as sa from sqlalchemy.orm import declarative_base from sqlaurum import UUID , GenerateUUID , create_repository_class Base = declarative_base () class User ( Base ): __tablename__ = \"user\" id = sa . Column ( UUID (), primary_key = True , server_default = GenerateUUID (), nullable = False ) name = sa . Column ( sa . Unicode ( 255 )) SQLAlchemyRepository = create_repository_class ( \"postgresql\" ) class UserRepository ( SQLAlchemyRepository [ User ]): async def get_user_by_name ( self , name : str ): # custom user function return await self . select () . filter_by ( name = name ) . one () user_repository = UserRepository ( ... ) # select await user_repository . all () await user_repository . select () . where ( User . name == \"test\" ) # insert user = await user_repository . insert ({ \"name\" : \"test\" }) . one () await user_repository . commit () # upsert await user_repository . upsert ({ \"name\" : \"John\" }) # delete await user_repository . delete ( name = \"John\" ) # custom sqlalchemy core functions users = await user_repository . select () . join ( ... ) . filter ( User . name == \"test\" ) . filter_by ( ... ) . order_by ( User . created_at ) . limit ( 2 ) . all ()","title":"Usage"},{"location":"usage/#sessions","text":"Repository object needs sqlalchemy.ext.asyncio.AsyncSession , but it's possible to provide the session object by yourself, by subclassing Repository class e.g. from fastapi import Depends from sqlalchemy.ext.asyncio import create_async_engine , AsyncSession from sqlaurum import create_repository_class , create_session_factory engine = create_async_engine ( \"sqlite+aiosqlite:///:memory:\" ) get_db = create_session_factory ( engine ) BaseSQLAlchemyRepository = create_repository_class ( engine ) class SQLAlchemyRepository ( BaseSQLAlchemyRepository , abstract = True ): \"\"\"Base manager, which uses fastapi depends to get session object\"\"\" def __init__ ( self , session : AsyncSession = Depends ( get_db )): super () . __init__ ( session ) class UserRepository ( SQLAlchemyRepository [ User ]): ... # then in fastapi from fastapi import FastAPI app = FastAPI () @app . get ( \"/users\" ) async def get_users ( user_repo : UserRepository = Depends ( UserRepository )): users = await user_repo . all () return users","title":"Sessions"}]}